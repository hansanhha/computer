[연결 리스트](#연결-리스트)

[연결 리스트 종류](#연결-리스트-종류)

[연결 리스트 기본 작업](#연결-리스트-기본-작업)
 - [삽입](#삽입)

## 연결 리스트

**연결 리스트가 필요한 이유**

메모리 공간은 컴퓨터 시스템의 전체 프로그램이 공통적으로 사용하는 자원임

배열은 인접한 메모리 공간을 연속적으로 사용하는데, 되게 큰 데이터들을 담아야 될 경우에 그만한 인접 메모리 공간을 찾기 어려움

반면 연결 리스트는 배열과 같이 선형 자료구조에 속하지만, 실제로는 메모리를 분산해서 데이터를 저장하기 때문에 이런 상황에서 배열보다 효율적으로 메모리를 사용할 수 있음

**연결 리스트 구성 요소**

연결 리스트에 속한 요소를 "노드(node)"라고 함

각 노드는 자신의 "데이터(value)"와 다음 노드의 메모리 주소를 가리키는 "참조(references, pointer)"를 가짐

노드는 다음 노드의 주소를 알고 있으므로 인접한 메모리 공간의 필요가 없게 되지만, 배열에 비해 더 많은 메모리 공간을 필요로 함

맨 처음 노드를 head node, 맨 마지막 노드를 tail node라고 함

## 연결 리스트 종류

### 단일 연결 리스트 (Singly Linked List)

<img src="./images/Singly linked list.png" alt="단일 연결 리스트">

각 노드가 다음 노드의 주소만 알고 있는 연결 리스트

tail 노드의 포인터는 null 값을 가짐

한 방향으로만 이동이 가능하고, tail 노드가 순회의 끝임

### 이중 연결 리스트 (Doubly Linked List)

<img src="./images/Doubly linked list.png" alt="이중 연결 리스트">

각 노드가 이전 노드와 다음 노드의 주소를 알고 있는 연결 리스트

head 노드의 이전 노드 포인터 값과 tail 노드의 다음 노드 포인터는 null 값을 가짐

각 노드 간 양방향 이동이 가능함

### 원형 연결 리스트 (Circular Linked List)

<img src="./images/Circularly linked list.png" alt="원형 연결 리스트">

단일 연결 리스트이면서, tail 노드가 head 노드에 연결되어 있는 연결 리스트

tail 노드의 포인터는 head 노드를 가리킴

한 방향으로만 이동이 가능하지만, tail 노드 방문 이후 다시 head 노드부터 순회를 돌 수 있음

### 원형 이중 연결 리스트 (Circular Doubly Linked List)

이중 연결 리스트이면서, head 노드와 tail 노드가 서로 연결되어 있는 연결 리스트

head 노드에서 tail 노드로 이동할 수 있음

어느 방향으로든지 이동 가능

## 연결 리스트 기본 작업

### 초기화

초기화는 두 단계로 이뤄짐

1. 노드 생성
2. 노드 간 참조 형성

배열은 인덱스를 통해서 값 자체에 바로 접근할 수 있지만, 노드는 하나의 객체이기에 참조를 통해 다음 노드에 접근할 수 있음

```c
// 단일 연결 리스트, 원형 연결 리스트
typedef struct CNode {
    int data;
    struct CNode* next;
} CNode;
```

```c
// 이중 연결 리스트, 원형 이중 연결 리스트
typedef struct DNode {
    int data;
    struct DNode* prev;
    struct DNode* next;
} DNode;
```

### 삽입

삽입할 위치를 알고 있는 경우에 `O(1)`의 시간 복잡도를 가짐

해당 위치에 근접한 노드들의 포인터만 바꾸면 됨

```c
// 단일 연결 리스트
void insertAtHead(CNode** head, int data) {
    CNode* newNode = create(data);
    newNode->next = *head;
    *head = newNode;
}
```

위의 함수는 head에 새 노드를 넣고 새 head 노드가 기존의 head를 가리키게 함

새로운 노드를 생성한 뒤, 새 노드의 next가 head를 가리키게 함

그리고 head 노드를 새 노드로 변경함


```c
// 원형 연결 리스트
void insertAtTail(CNode** tail, int data) {
    CNode* newCNode = create(data);
    
    if (*tail == NULL) {
        *tail = newCNode;
        (*tail)->next = newCNode;
    } else {
        newCNode->next = (*tail)->next;
        (*tail)->next = newCNode;
        *tail = newCNode;
    }
}
```

위의 함수는 tail 노드에 새 노드를 넣고, 새 tail 노드가 head를 가리키게 함

tail 노드가 null인 경우 새 노드를 tail 노드로 하고,

아닌 경우 tail 노드의 next 값을 새 노드의 next에 넣은 다음 tail 노드의 next 값을 새 노드로 함

그리고 tail 노드를 새 노드로 지정함

```c
// 이중 연결 리스트
void insertAtHead(DNode** head, int data) {
    DNode* newNode = create(data);
    (*head)->prev = newNode;
    newNode->next = *head;
    *head = newNode;
}
```

위의 함수는 head에 새 노드를 넣고 새 head 노드가 기존의 head를 가리키게 함

단일 연결 리스트와는 다르게 이전 노드의 포인터도 있기 때문에 기존 head의 prev 포인터를 새 노드로 지정함

### 삭제




